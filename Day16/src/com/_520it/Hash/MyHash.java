package com._520it.Hash;

/**
 * Created by mudy on 18/3/21.
 */
public class MyHash {



}

/** 哈希表
 *  又被称为散列表
 *
 *  在一般的数组中，元素在数组中的索引位置是随机的，元素的取值和元素之间的位置之间不存在确定的关系，
 *  因此，在数组中查找特定的值时，需要把查找值和一系列的元素进行比较
 *  此时的查询效率依赖于查找过程中所进行的比较的次数
 *  如果元素的值(value)和在数组中的索引位置(index)有一个确定的对应关系(hash)
 *  公式为index = hash(value)
 *  那么对于给定的值，只要调用上述的hash(value)方法，就能找到数组中取值为Value的位置
 *
 *  如果数组中元素的值和索引位置存在对应的关系，这样的数组就称之为哈希表，
 *  可以看出，哈希表的最大的优点是供提查找数据的效率
 *  一般情况下，我们是不会把哈希码作为元素在数组中的索引的位置的，因为哈希码很大，数组长度有限，会造成索引越界的问题
 *  这个时候，我们可以在哈希码和元素位置之间做某种映射关系
 *
 *  元素值  ---hash(vaule) ----> 哈希码 ----某种映射关系----> 元素的存储索引
 *
 *  注意:每个对象的哈希码是不同的
 *
 *  哈希是一个特殊的数组，哈希表的查询速度特别快
 *
 *  哈希表接近装满的时候，因为数组的扩容的问题，性能较低(转移到更大的哈希表中)
 *
 *  加载因子:在java中默认是0.75,容量是16，所以当有12个时候，就会考虑重新哈希化了。
 *
 *  不会记录添加的顺序的，对象如果相同，则hashcode相同，index相同，就会覆盖。
 *  数组会记录添加的顺序的，按照索引位置来存储的，允许元素重复
 */

/** 树结构
 *  在做范围查询的时候，性能超群，一般的用来做索引的结构
 */